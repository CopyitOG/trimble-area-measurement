<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surface Area Measurement</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 16px;
            min-height: 100vh;
        }

        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 20px;
            max-width: 400px;
        }

        h1 {
            font-size: 22px;
            color: #333;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
        }

        .status {
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 16px;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
            border-left: 4px solid #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #2e7d32;
            border-left: 4px solid #2e7d32;
        }

        .status.warning {
            background: #fff3e0;
            color: #e65100;
            border-left: 4px solid #ff9800;
        }

        .measurement-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 24px;
            color: white;
            margin-bottom: 16px;
            display: none;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }

        .measurement-card.visible {
            display: block;
        }

        .area-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.9;
            margin-bottom: 8px;
        }

        .area-value {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .area-unit {
            font-size: 18px;
            opacity: 0.9;
        }

        .object-info {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 13px;
            border-bottom: 1px solid #e0e0e0;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #666;
            font-weight: 500;
        }

        .info-value {
            color: #333;
            font-family: monospace;
        }

        .log {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            font-size: 11px;
            font-family: monospace;
            max-height: 200px;
            overflow-y: auto;
            color: #666;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>
            <div class="icon">üìê</div>
            Surface Area Tool
        </h1>

        <div id="status" class="status info">
            Connecting to Trimble Connect...
        </div>

        <div id="measurement-card" class="measurement-card">
            <div class="area-label">Surface Area</div>
            <div class="area-value" id="area-value">0.00</div>
            <div class="area-unit">m¬≤</div>
        </div>

        <div id="object-info" class="object-info" style="display:none;">
            <div class="info-row">
                <span class="info-label">Object ID:</span>
                <span class="info-value" id="object-id">--</span>
            </div>
            <div class="info-row">
                <span class="info-label">Model ID:</span>
                <span class="info-value" id="model-id">--</span>
            </div>
            <div class="info-row">
                <span class="info-label">Position:</span>
                <span class="info-value" id="position">--</span>
            </div>
        </div>

        <div id="log" class="log"></div>
    </div>

    <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>
    <script>
        function log(msg) {
            console.log(msg);
            const logDiv = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            logDiv.textContent = `[${time}] ${msg}\n` + logDiv.textContent;
        }

        log('[Area Tool] Initializing...');

        let API = null;
        const statusDiv = document.getElementById('status');
        const measurementCard = document.getElementById('measurement-card');
        const areaValue = document.getElementById('area-value');
        const objectInfo = document.getElementById('object-info');
        const objectIdSpan = document.getElementById('object-id');
        const modelIdSpan = document.getElementById('model-id');
        const positionSpan = document.getElementById('position');

        function updateStatus(message, type) {
            statusDiv.className = 'status ' + type;
            statusDiv.textContent = message;
        }

        async function calculateArea(pickData) {
            const pos = pickData.position;
            const objId = pickData.objectRuntimeId;
            const modelId = pickData.modelId;

            log(`[Pick] Object: ${objId}, Model: ${modelId}`);
            log(`[Pick] Position: ${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}`);

            // Display basic info
            objectIdSpan.textContent = objId || 'N/A';
            modelIdSpan.textContent = modelId || 'N/A';
            positionSpan.textContent = `${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}`;
            objectInfo.style.display = 'block';

            try {
                log('[API] Available viewer methods: ' + (API.viewer ? Object.keys(API.viewer).join(', ') : 'none'));

                // Method 1: Try getObjectProperties
                if (API.viewer && API.viewer.getObjectProperties) {
                    log('[API] Trying getObjectProperties...');
                    const props = await API.viewer.getObjectProperties([objId]);

                    if (props && props.length > 0) {
                        log('[Props] SUCCESS: ' + JSON.stringify(props[0]).substring(0, 500));
                        const obj = props[0];

                        // Look for area in various places
                        let area = obj.area || obj.surfaceArea || obj.Area || obj.SurfaceArea;

                        if (!area && obj.properties) {
                            for (let key in obj.properties) {
                                if (key.toLowerCase().includes('area')) {
                                    area = obj.properties[key];
                                    log(`[Area] Found: ${key} = ${area}`);
                                    break;
                                }
                            }
                        }

                        if (area) {
                            displayArea(area);
                            return;
                        }

                        // Try bounding box from properties
                        if (obj.boundingBox) {
                            estimateFromBoundingBox(obj.boundingBox);
                            return;
                        }
                    } else {
                        log('[Props] Empty result - trying alternatives');
                    }
                }

                // Method 2: Try getBoundingBox
                if (API.viewer && API.viewer.getBoundingBox) {
                    log('[API] Trying getBoundingBox...');
                    const bbox = await API.viewer.getBoundingBox([objId]);
                    log('[BBox] Result: ' + JSON.stringify(bbox));
                    if (bbox) {
                        estimateFromBoundingBox(bbox);
                        return;
                    }
                }

                // Method 3: Try getSelection
                if (API.viewer && API.viewer.getSelection) {
                    log('[API] Trying getSelection...');
                    const selection = await API.viewer.getSelection();
                    log('[Selection] Result: ' + JSON.stringify(selection).substring(0, 300));
                    if (selection && selection.objectRuntimeIds && selection.objectRuntimeIds.length > 0) {
                        // Selection worked but may not have area
                        log('[Selection] Has objects but no area data');
                    }
                }

                // Method 4: Calculate from pick normal (rough estimate)
                if (pickData.normal) {
                    log('[Calc] Using pick normal for rough estimate');
                    // Very rough: assume 1m x 1m surface
                    displayArea(1.0);
                    return;
                }

                // Fallback
                log('[Fallback] Using default 1.0 m¬≤');
                displayArea(1.0);

            } catch (error) {
                log(`[Error] ${error.message}`);
                log(`[Error] Stack: ${error.stack}`);
                displayArea(1.0);
            }
        }

        function estimateFromBoundingBox(bbox) {
            log('[BBox] Estimating from bounding box');

            if (!bbox.min || !bbox.max) {
                log('[BBox] Invalid bbox');
                displayArea(1.0);
                return;
            }

            const width = Math.abs(bbox.max.x - bbox.min.x);
            const height = Math.abs(bbox.max.y - bbox.min.y);
            const depth = Math.abs(bbox.max.z - bbox.min.z);

            log(`[BBox] Dimensions: ${width.toFixed(2)} x ${height.toFixed(2)} x ${depth.toFixed(2)}`);

            // Calculate surface areas of each face
            const areas = [
                width * height,
                width * depth,
                height * depth
            ];

            // Use the largest face
            const maxArea = Math.max(...areas);
            log(`[BBox] Max face area: ${maxArea.toFixed(2)} m¬≤`);

            displayArea(maxArea);
        }
        function displayArea(area) {
            // Convert to m¬≤ if needed
            let areaM2 = parseFloat(area);
            if (areaM2 < 1) areaM2 *= 1000000; // Assume mm¬≤ to m¬≤

            areaValue.textContent = areaM2.toFixed(2);
            measurementCard.classList.add('visible');
            log(`[Area] Displayed: ${areaM2.toFixed(2)} m¬≤`);
        }

        function estimateArea(obj) {
            log('[Estimate] Using bounding box...');

            if (obj.boundingBox) {
                const bb = obj.boundingBox;
                // Rough estimate: use bounding box dimensions
                const width = Math.abs(bb.max.x - bb.min.x);
                const height = Math.abs(bb.max.y - bb.min.y);
                const depth = Math.abs(bb.max.z - bb.min.z);

                // Estimate largest face
                const areas = [
                    width * height,
                    width * depth,
                    height * depth
                ];
                const maxArea = Math.max(...areas);

                displayArea(maxArea);
            } else {
                displayArea(1.0); // Default
            }
        }

        function estimateAreaFromPick(pickData) {
            // Very rough estimate: 1 m¬≤ default
            log('[Estimate] Using default area');
            displayArea(1.0);
        }

        function handleEvent(event, data) {
            const eventData = data && data.data ? data.data : data;

            if (event === 'viewer.onPicked' && eventData && eventData.position) {
                log('[Pick] Surface clicked');
                calculateArea(eventData);
            }
        }

        (async function init() {
            try {
                log('[API] Connecting...');
                API = await TrimbleConnectWorkspace.connect(window.parent, handleEvent);

                log('[API] ‚úì Connected!');
                updateStatus('Ready! Click on surfaces to measure area', 'success');

            } catch (error) {
                log(`[API] ERROR: ${error.message}`);
                updateStatus('Connection failed', 'warning');
            }
        })();
    </script>
</body>

</html>